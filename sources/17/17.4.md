“Wrote stack traces to tombstoned” 这条信息表明 **Android 系统捕获到了一个严重的 Native 崩溃（C/C++ 代码崩溃）**，并且已经将崩溃时的栈回溯信息写入了 Android 的墓碑系统。这是一种比普通的 Java 异常崩溃更底层、更严重的错误。

下面是如何查看和分析这种崩溃的步骤：

### 1. 理解“墓碑”文件
*   **位置**：在 Android 设备上，墓碑文件通常保存在 `/data/tombstones/` 目录下（需要 root 权限）。有时也可能在 `/data/anr/` 或 `/data/crash/` 目录。
*   **内容**：它是一个纯文本文件，包含了崩溃时详细的系统状态，最核心的部分就是 **栈回溯**，它能告诉你崩溃时代码执行到了哪个函数、哪一行（如果有符号表的话）。

### 2. 获取墓碑文件（需要 Root 权限）
如果你的设备已 Root，可以通过 ADB 命令获取：

```bash
# 1. 连接到设备
adb shell

# 2. 切换到墓碑目录（可能需要 su）
su
cd /data/tombstones/

# 3. 列出文件，通常命名为 tombstone_XX
ls -la

# 4. 找到最新的文件（按时间排序），将其拉取到电脑
# 先退出 adb shell（按 Ctrl+D 或输入 exit）
exit
# 拉取文件，例如 tombstone_00
adb pull /data/tombstones/tombstone_00 .
```

**重要提示**：对于非 Root 设备，直接访问 `/data/tombstones/` 通常会被拒绝。你可以通过以下替代方案获取崩溃信息。

### 3. 替代方案：使用 ADB Logcat 捕获崩溃瞬间
在崩溃发生后，**立即** 使用 `adb logcat` 命令捕获日志。最好在运行应用前就开始记录，并过滤相关进程。

```bash
# 清除旧日志
adb logcat -c

# 开始记录，可以保存到文件
adb logcat -v time > crash_log.txt

# 或者在终端实时查看，并过滤包含“tombstone”、“fatal”、“signal”或你应用包名的行
adb logcat | grep -E “tombstone|fatal|signal|com.your.package”
```

当崩溃发生时，logcat 会输出大量信息，其中就包含从墓碑中提取的栈回溯。在日志中搜索 `backtrace:`、`signal`、`pid` 等关键词来定位关键部分。

### 4. 分析栈回溯
拿到墓碑文件或日志中的栈回溯后，它看起来可能像这样：

```
backtrace:
    #00 pc 00012345  /data/app/com.example.app/lib/arm64/libnative-lib.so (function_name+123)
    #01 pc 00023456  /data/app/com.example.app/lib/arm64/libnative-lib.so (another_function+456)
    #02 pc 00034567  /system/lib64/libc.so (__libc_init+789)
```

**关键信息**：
*   `pc`：程序计数器，崩溃时的内存地址。
*   库/共享对象文件（如 `libnative-lib.so`）：崩溃发生在哪个原生库。
*   `(function_name+offset)`：最重要的部分。它告诉你崩溃发生在哪个函数，以及距离函数开头的偏移量。

### 5. 将地址转换为可读的代码行（符号化）
原始的栈回溯只有内存地址和偏移量。要看到具体的**函数名和行号**，你需要使用 **NDK 工具链中的 `addr2line` 或 `ndk-stack`**。

#### 方法 A：使用 `ndk-stack`
这是最简单的方法，尤其是当你有完整的墓碑文件时。

1.  **确保你拥有编译该 `.so` 文件时生成的 `符号文件（Symbol File）`**。对于 Release 构建，这通常是带调试符号的 `.so` 文件（体积很大），或者专门的 `.sym` 文件。关键是要**和发布到设备上的 `.so` 文件完全对应**。
2.  在命令行中运行：

    ```bash
    # 假设你的符号文件（带调试符号的 .so）在 ./app/build/intermediates/cmake 等目录下
    # 或者使用 NDK 提供的工具
    ndk-stack -sym /path/to/your/symbols/directory -dump tombstone_00
    ```

    `ndk-stack` 会自动解析墓碑文件，并将地址替换为函数名和行号。

#### 方法 B：使用 `addr2line`
更手动，但更灵活。

1.  同样，准备好带调试符号的 `.so` 文件。
2.  从栈回溯中复制一个地址（例如 `00012345`）和对应的库路径。
3.  运行：

    ```bash
    # arm64-v8a 架构示例，其他架构工具路径不同
    $ANDROID_NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-addr2line -e /path/to/your/symbols/libnative-lib.so 00012345
    ```

    `-e` 指定可执行文件（即你的 .so）。
    它会输出类似 `function_name` 和 `file.cpp:123` 的信息。

### 6. 常见崩溃原因
查看栈回溯顶部，通常能发现线索：
*   **信号（Signal）**：墓碑开头会显示导致崩溃的信号，如 `SIGSEGV`（段错误，非法内存访问）、`SIGABRT`（中止，通常因 `assert` 或 `abort()` 调用）、`SIGBUS`（总线错误）等。
*   **内存问题**：
    *   空指针解引用。
    *   访问已释放内存（Use-after-free）。
    *   缓冲区溢出（数组越界）。
    *   堆破坏。
*   **JNI 错误**：在 JNI 调用中使用了错误的 `jobject`，或没有正确处理 Java 异常。
*   **多线程问题**：竞态条件、死锁，或在没有正确同步的情况下访问共享数据。

### 7. 对于非 Root 设备的开发/测试建议
1.  **在本地调试**：如果你是在开发过程中遇到此问题，最好在 Android Studio 的调试模式下运行应用。当 Native 崩溃发生时，调试器会自动中断并显示崩溃位置和调用栈。
2.  **生成可调试的 APK**：构建一个带有调试符号（`android:debuggable=”true”` 且在 `build.gradle` 中配置了 `debug` 或包含符号的 Release 构建）的 APK 进行测试。
3.  **使用 Crashlytics 等第三方服务**：Firebase Crashlytics 等工具可以自动收集和符号化 Native 崩溃报告，即使在用户设备上也非常有效。你需要按照其文档上传符号文件（`.so` 或 `.sym`）。

### 总结步骤
1.  **获取崩溃信息**：通过 Root 设备拉取墓碑文件，或通过 `adb logcat` 立即捕获日志。
2.  **定位栈回溯**：在文件中找到 `backtrace:` 部分。
3.  **符号化**：使用 `ndk-stack` 和**对应版本**的调试符号文件，将地址转换为代码行。
4.  **分析代码**：查看转换后的栈顶函数，结合信号类型，分析崩溃原因。

如果你能提供墓碑文件中 `backtrace:` 部分的内容，我可以帮你进行初步的分析，判断可能的问题方向。