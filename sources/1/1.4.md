好的，这是一个 Android 开发中非常核心且常见的面试题。四种启动模式决定了 Activity 如何与任务栈交互，从而影响应用的导航行为和用户体验。

下面我将详细解释它们的区别、原理以及典型应用场景。

---

### 核心概念：任务栈

在理解启动模式之前，必须先了解**任务栈**。
*   它是一个“后进先出”的栈结构，用于存放和管理 Activity 实例。
*   每个应用在启动时通常会创建一个属于自己的任务栈。
*   用户看到的“返回栈”可能由一个或多个任务栈组成。

---

### 1. standard（标准模式）

#### **定义与行为**
*   **默认模式**。如果不指定，所有 Activity 都使用此模式。
*   每次启动该 Activity（即使是要启动的 Activity 已经在栈顶），**都会创建一个新的实例**，并放入当前任务栈中。

#### **原理图**
```
任务栈状态: [A, B, C]  // 栈底是A，栈顶是C
在 C 中启动 B（standard 模式）：
结果: [A, B, C, B]  // 创建了一个新的B实例，并压入栈顶
```
此时按返回键，会依次退出 `B -> C -> B -> A`。

#### **应用场景**
*   **绝大多数普通页面**。比如新闻列表页、设置页、普通的详情页等。
*   适用于那些可以同时存在多个实例、且与上下文无关的页面。

#### **注意事项**
*   在非 Activity 的 Context（如 Service 的 Context）中启动 standard 模式的 Activity 时，必须加上 `FLAG_ACTIVITY_NEW_TASK` 标志，因为它需要在一个新的任务栈中创建实例。

---

### 2. singleTop（栈顶复用模式）

#### **定义与行为**
*   如果要启动的 Activity **已经位于当前任务栈的栈顶**，则不会创建新实例，而是**复用这个已有的栈顶实例**，并会回调其 `onNewIntent()` 方法。
*   如果要启动的 Activity **不在栈顶**，则行为与 standard 模式一样，**会创建新的实例**。

#### **原理图**
**情况一：目标 Activity 在栈顶**
```
任务栈状态: [A, B, C]  // C在栈顶
在 C 中启动 C（singleTop 模式）：
结果: [A, B, C]  // 不会创建新实例，复用C，触发C的onNewIntent()
```

**情况二：目标 Activity 不在栈顶**
```
任务栈状态: [A, B, C]  // B不在栈顶
在 C 中启动 B（singleTop 模式）：
结果: [A, B, C, B] // 创建了一个新的B实例
```

#### **应用场景**
*   **防止快速连续点击导致出现多个相同页面**。例如，一个“详情页”的入口按钮被连续点击多次，如果使用 standard 模式会创建多个一样的详情页。
*   **通知栏点击跳转**。当应用已经打开在某个页面，通过通知栏跳转回该页面时，通常希望复用现有实例并更新数据。
*   **搜索页**。用户可能在搜索页反复进行搜索，复用同一个实例可以避免内存浪费和混乱的返回栈。

---

### 3. singleTask（栈内复用模式）

#### **定义与行为**
*   Activity 在系统中**全局单例**。系统会为它**分配一个独立的任务栈**。
*   启动时，系统会**检查是否存在该 Activity 需要的任务栈**：
    *   **如果不存在**：则创建新的任务栈，并创建该 Activity 实例放入栈底。
    *   **如果存在**：则直接切换到该任务栈。同时，会**检查该任务栈中是否已经存在此 Activity 的实例**。
        *   如果存在，则将该实例**之上的所有其他 Activity 全部出栈**，使其成为栈顶，并回调 `onNewIntent()`。
        *   如果不存在，则创建新实例并压入此任务栈。

#### **原理图**
**情况一：不存在所需任务栈**
```
启动 S（singleTask）：
创建新任务栈 Task1: [S]
```

**情况二：存在任务栈，且目标 Activity 在栈中**
```
现有任务栈 Task1: [S, A, B, C]  // S在栈底
在其他任务栈中启动 S（singleTask）：
结果 Task1: [S]  // 清空S之上的所有Activity，S回到栈顶并触发onNewIntent()
```

**情况三：存在任务栈，但目标 Activity 不在栈中**
（这种情况较少见，通常 singleTask Activity 在栈底）
```
现有任务栈 Task1: [A, B, C]
在其他任务栈中启动 S（singleTask）：
结果 Task1: [A, B, C, S]  // 在已有任务栈中创建S实例
```

#### **应用场景**
*   **应用的主页（MainActivity）**。这是最经典的应用场景。无论从哪个深层页面，点击返回都应该能一层层退回主页，而不是再创建一个新的主页。它确保了“一个应用只有一个主页”。
*   **登录页**。当在应用内进行某些操作需要登录时，跳转到登录页。登录成功后，应该回到原页面，并且按返回键不应该再回到登录页。通过 `clearTop` 效果可以实现。
*   **应用间交互**。例如，浏览器应用声明它的网页浏览 Activity 是 singleTask 的，这样当其他应用调用浏览器时，都会复用同一个浏览器任务栈，而不是为每个链接都打开一个新的浏览器。

---

### 4. singleInstance（单实例模式）

#### **定义与行为**
*   这是 **singleTask 的强化版**。
*   具有此模式的 Activity 会**独占一个任务栈**，并且**这个任务栈中有且仅有它一个 Activity**。
*   后续再请求启动这个 Activity，都不会创建新实例，而是直接复用这个独占任务栈中的实例，并回调 `onNewIntent()`。
*   它总是处于任务栈的栈顶。

#### **原理图**
```
1. 启动 I（singleInstance）：
   创建新任务栈 Task2: [I]  // I独占一个栈

2. 在 I 中启动 A（standard）：
   回到原来的任务栈 Task1（或创建新的默认栈）: [A]
   Task2 保持不变: [I]

3. 在 A 中再启动 I（singleInstance）：
   不会创建新实例，而是将整个 Task2 栈切换到前台。
   此时返回栈情况：前台是 Task2[I]，后台是 Task1[A]。
   从 I 按返回键，会回到 A。
```

#### **应用场景**
*   **系统 Launcher（桌面）**。确保全局只有一个桌面。
*   **来电界面**。需要快速响应并独占整个屏幕，不希望被其他 Activity 干扰。
*   **需要被多个应用共享的 Activity**。例如，一个“分享到”的选择器页面。由于它非常特殊且需要被系统级复用，所以使用 singleInstance。
*   **注意**：由于 singleInstance 的 Activity 通常不与其他 Activity 处于同一个任务栈，它们之间的过渡动画可能会不协调，且返回逻辑可能让用户感到困惑，因此**除非有非常明确的需求，否则应谨慎使用**。

---

### 总结对比表格

| 启动模式 | 是否创建新实例 | 任务栈 | 特点 | 典型场景 |
| :--- | :--- | :--- | :--- | :--- |
| **standard** | **总是创建** | **当前任务栈** | 默认模式，允许多个实例 | 普通页面 |
| **singleTop** | **不在栈顶时创建** | **当前任务栈** | **栈顶复用**，防止重复打开 | 详情页、搜索页、通知跳转 |
| **singleTask** | **不在栈内时创建** | **独立任务栈** | **栈内复用**，**清除栈顶** | **应用主页**、登录页 |
| **singleInstance** | **系统内无实例时创建** | **独占任务栈** | **全局单例**，**栈内唯一** | 桌面、来电界面 |

### 如何设置启动模式

1.  **在 AndroidManifest.xml 中静态声明**：
    ```xml
    <activity
        android:name=".MainActivity"
        android:launchMode="singleTask" />
    ```

2.  **通过 Intent Flag 动态设置**（优先级高于静态声明）：
    ```java
    Intent intent = new Intent(this, MainActivity.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 模拟 singleTask 行为
    // intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); // 模拟 singleTop 行为
    // intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); // 常与 NEW_TASK 配合使用
    startActivity(intent);
    ```

理解并正确使用启动模式，是构建清晰、符合用户预期的应用导航结构的关键。