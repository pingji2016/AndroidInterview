这几个问题非常专业，触及了 SQLite 和 Room 的核心机制。我来一一为您深入解答。

### 1. `room_master_table` 是什么？
确实不是您创建的。
*   **作用**：这是 **Room 框架自己维护的一张“身份证”表**。
*   **内容**：它里面通常只有一行数据，记录了一个 **`identity_hash` (哈希值)**。
*   **目的**：Room 在运行时会对比代码中生成的哈希值和这张表里的哈希值。
    *   如果匹配，说明数据库结构（Schema）和代码是同步的，可以安全使用。
    *   如果不匹配，说明您改了 Entity 代码但没升级版本号/没做迁移，Room 就会抛出异常，防止数据损坏。

---

### 2. 为什么是“三个文件”？(WAL 模式)
这三个文件（.db, .db-wal, .db-shm）并不是“三张表”，而是 **同一个数据库在 WAL (Write-Ahead Logging) 模式下的物理存储形态**。

这是 **SQLite** 自身的高级特性，Room 默认开启了它（因为性能更好）。

#### 原理：
*   **传统模式 (Journal)**：写数据时，先把旧数据备份到日志，然后**锁住整个数据库**，直接修改主文件 (.db)。这导致**读写互斥**（写的时候不能读，读的时候不能写），并发性能差。
*   **WAL 模式 (现代模式)**：
    *   **读**：直接读主文件 (.db) + 还没合并的 WAL 文件 (.db-wal)。
    *   **写**：**不修改主文件**，而是把新数据**追加**到 `.db-wal` 文件末尾。
    *   **优势**：**读写完全分离！** 您可以在写入数据的同时，另一个线程毫无阻塞地读取数据。这对于 UI 流畅性至关重要。

---

### 3. 如何保证数据一致性？怎么查到最新的？

您可能会担心：*“数据一部分在 .db，一部分在 .db-wal，我查的时候会不会漏掉？”*

**完全不会。SQLite 引擎自动处理了一切。**

*   **读取逻辑**：当您发起查询（Select）时，SQLite 会利用 **`.db-shm` (共享内存索引)** 来判断哪些页面在 WAL 里有更新的版本。
    *   如果 WAL 里有新版，就读 WAL 里的。
    *   如果 WAL 里没有，就读主文件里的。
*   **结果**：对上层用户（您）来说，**看到永远是整合后最新、最完整的视图**。您完全不需要关心数据物理上到底在哪。

---

### 4. 多个读写怎么保证一致性？

*   **多读**：支持无限个并发读取，互不干扰。
*   **一写**：同一时刻只能有一个写入者。WAL 模式下，写操作追加到 WAL 文件末尾，非常快。
*   **事务 (Transaction)**：Room 的所有操作（Insert/Update）默认都包裹在事务中。
    *   **原子性**：要么全成功，写入 WAL；要么全失败，WAL 保持原样。
    *   **隔离性**：在写入完成并提交（Commit）之前，其他读取者是看不到这条新数据的（它们看到的是旧版本）。只有提交的一瞬间，新数据才对所有读取者可见。

---

### 总结
1.  **`room_master_table`**：Room 的“防伪标签”，确保代码和数据库版本匹配。
2.  **3个文件**：是 **SQLite 的 WAL 模式** 产物，不是 3 张表。
    *   `.db`：老数据仓库。
    *   `.db-wal`：新数据暂存区（追加写，速度快）。
    *   `.db-shm`：目录索引（告诉读者去哪找最新的）。
3.  **一致性**：SQLite 引擎底层自动合并视图，利用事务机制保证 ACID（原子性、一致性、隔离性、持久性）。

Room 选择这个模式，就是为了让您的 App 在记录传感器高频数据时（写），界面还能流畅地查询展示（读），互不卡顿。


### 1. SQLite 要写日志吗？
**是的，必须写。** 无论是传统模式还是 WAL 模式，日志都是数据库崩溃恢复（Crash Recovery）和事务回滚（Rollback）的基础。

*   **传统模式 (Journal)**：写的是 **Rollback Journal**（回滚日志）。它存的是**修改前的旧数据**。
    *   *逻辑*：我要改 A=1 为 A=2。先把 "A=1" 抄到日志里 -> 修改主文件 A=2 -> 提交。
    *   *崩溃恢复*：如果改一半断电了，下次启动时检查日志，把 "A=1" 恢复回去。
*   **WAL 模式**：写的是 **Write-Ahead Log**（预写日志）。它存的是**修改后的新数据**。
    *   *逻辑*：我要改 A=1 为 A=2。直接把 "A=2" 追加到 WAL 文件末尾 -> 提交。主文件 A=1 根本不动。
    *   *崩溃恢复*：如果断电，WAL 里可能有一条不完整的记录，校验和不对，直接丢弃即可，主文件本身就是完好的。

### 2. WAL 合并时机与索引自定义
*   **多久合并 (Checkpoint)？**
    *   **自动触发**：默认配置下，当 WAL 文件大小达到 **1000 页**（通常约 4MB）时，SQLite 会自动触发 Checkpoint，把 WAL 里的数据搬运回 `.db` 主文件，并重置 WAL。
    *   **手动触发**：您可以在代码里调用 `WAL_CHECKPOINT` 指令强制合并。
    *   **关闭时**：当最后一个数据库连接关闭时，通常也会自动合并。
*   **`.db-shm` 索引能自定义吗？**
    *   **不能，也不需要。**
    *   SHM (Shared Memory) 是 SQLite 内核管理的**内存映射文件**。它的结构是非常底层的 Hash 表，专门用于在多进程/多线程间快速定位“某个页面最新版本是在 WAL 里还是在 DB 里”。这是 SQLite 内部黑盒机制，开发者无法也无需干预。

### 3. 传统模式的锁与 WAL 的引入历史
*   **传统模式也有日志，为什么还锁库？**
    *   因为传统模式是**直接修改主文件**。为了保证数据完整性，在修改期间（从写日志开始到修改完成），绝对不允许其他人读取主文件（否则会读到改了一半的脏数据）。
    *   所以它必须是一个 **EXCLUSIVE Lock (排他锁)**。一写锁全库，读也不能读。
*   **WAL 模式是 Android 几引入的？**
    *   **SQLite 层级**：SQLite 3.7.0 (2010年) 就引入了 WAL。
    *   **Android 系统层级**：Android 3.0 (Honeycomb) 开始在系统 Framework 的 SQLiteDatabase 中默认启用 WAL。
    *   **Room 框架**：Room 从诞生之初（Android Architecture Components, 2017年）就默认开启 WAL 模式。因为它主要服务于 UI 线程读取数据，非阻塞读对 Android App 体验太关键了。

### 总结对比

| 特性 | 传统模式 (Delete Journal) | WAL 模式 (Write-Ahead Log) |
| :--- | :--- | :--- |
| **日志内容** | **旧数据** (用于撤销) | **新数据** (用于生效) |
| **写操作位置** | 直接改 **.db 主文件** | 追加到 **.db-wal 文件** |
| **并发性** | **读写互斥** (写的时候全卡住) | **读写分离** (写不挡读，读不挡写) |
| **Checkpoint** | 不需要 (实时写回) | 需要 (定期搬运) |
| **适用场景** | 极低并发、只读设备 | **移动端 App (高频读写)** |

这就是为什么您在 `db_export` 里会看到三个文件，这是现代高性能 Android 数据库的标准配置。