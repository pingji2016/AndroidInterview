好的，我们来详细讲解 Android 中 `BroadcastReceiver` 的两种注册方式及其区别。

### 概述

`BroadcastReceiver`（广播接收器）是 Android 中用于在应用内或应用间进行通信的一种组件。它用来接收来自系统或其他应用发出的广播消息。要让它工作，必须对其进行注册，告诉系统它想监听哪种广播。

注册方式有两种：
1. **静态注册**：在 `AndroidManifest.xml` 文件中声明。
2. **动态注册**：在代码（如 Activity 或 Service）中通过 `Context.registerReceiver()` 方法注册。

---

### 1. 静态注册

静态注册是在应用的清单文件中通过 `<receiver>` 标签来声明的。即使应用本身未运行，在特定条件下（如广播到来时）系统也可以唤醒应用进程来执行接收器。

#### 使用方法

在 `AndroidManifest.xml` 中添加：

```xml
<receiver
    android:name=".MyStaticReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <!-- 指定要监听的广播动作 -->
        <action android:name="android.intent.action.BOOT_COMPLETED" />
        <action android:name="android.net.conn.CONNECTIVITY_CHANGE" /> <!-- 注意：对于网络变化，高版本API限制静态注册 -->
    </intent-filter>
</receiver>
```

然后创建接收器类：

```java
public class MyStaticReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (action != null) {
            if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
                // 处理开机完成逻辑
                Log.d("MyStaticReceiver", "System boot completed!");
            }
        }
    }
}
```

#### 特点
*   **生命周期**：接收器本身在 `onReceive` 被调用时存在，执行完毕后系统认为其生命周期结束。
*   **进程**：当指定的广播到来时，如果应用进程不存在，**系统会主动创建应用进程**来执行 `onReceive` 方法。
*   **存活时间**：与应用是否运行无关。即使应用被关闭，只要广播事件发生，接收器就能被触发。

---

### 2. 动态注册

动态注册是在代码中（通常在 Activity 或 Service 的 `onCreate` 或 `onResume` 中）使用 `registerReceiver` 方法进行注册。它的生命周期与注册它的 `Context`（如 Activity）紧密相关。

#### 使用方法

在 Activity 中：

```java
public class MainActivity extends AppCompatActivity {
    private MyDynamicReceiver mReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 1. 创建接收器实例
        mReceiver = new MyDynamicReceiver();

        // 2. 创建 IntentFilter 并指定要监听的广播动作
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
        filter.addAction("com.example.my_custom_action"); // 自定义广播

        // 3. 注册接收器
        registerReceiver(mReceiver, filter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 4. 必须！在合适的时机（如onDestroy）解注册，避免内存泄漏和异常
        if (mReceiver != null) {
            unregisterReceiver(mReceiver);
            mReceiver = null;
        }
    }

    // 动态接收器的定义
    private class MyDynamicReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action != null) {
                if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
                    boolean isAirplaneModeOn = Settings.Global.getInt(
                            context.getContentResolver(),
                            Settings.Global.AIRPLANE_MODE_ON, 0) != 0;
                    Log.d("MyDynamicReceiver", "Airplane mode changed: " + isAirplaneModeOn);
                } else if (action.equals("com.example.my_custom_action")) {
                    Log.d("MyDynamicReceiver", "Received custom broadcast!");
                }
            }
        }
    }
}
```

#### 特点
*   **生命周期**：与注册它的 `Context` 绑定。例如，在 Activity 中注册，当 Activity 被销毁时，必须调用 `unregisterReceiver`，否则会导致内存泄漏，并且系统会抛出 `Receiver not registered` 异常。
*   **进程**：必须在应用进程运行时才能注册和接收广播。如果进程被杀死，动态注册的接收器也随之失效。
*   **灵活性**：可以随时注册和注销，更加灵活。

---

### 两种注册方式的区别总结

| 特性 | 静态注册 | 动态注册 |
| :--- | :--- | :--- |
| **声明位置** | `AndroidManifest.xml` | 代码（Java/Kotlin） |
| **生命周期** | 独立于应用组件，由系统管理 | 依赖于注册它的 **Context**（如 Activity） |
| **应用存活状态**| **应用未启动**也可接收广播（系统会唤醒） | 只有 **应用正在运行** 时才能接收广播 |
| **灵活性** | 不灵活，安装后即生效，直到应用被卸载 | 灵活，可根据业务逻辑随时注册和注销 |
| **系统广播限制**| 受 **Android 8.0 (API 26)** 限制，除少数例外，不能监听大部分**隐式**系统广播 | 在上下文存活期间，仍可监听许多系统广播（如飞行模式变化） |
| **资源消耗** | 可能会频繁唤醒应用，消耗更多电量/资源 | 资源消耗更可控，与组件生命周期同步 |
| **使用场景** | 需要**持久监听**特定全局事件，如**开机完成**、**应用安装/更新**（这些是豁免的隐式广播） | 监听与当前界面/服务逻辑相关的**临时性事件**，如**网络变化**（在Activity中）、**自定义广播**、**电量变化**等 |

---

### 重要注意事项（Android 8.0+ 的限制）

从 **Android 8.0 (Oreo, API 26)** 开始，为了优化性能和电池续航，系统对广播接收器施加了重要限制：

*   **静态注册**：**不能再监听大多数隐式的系统广播**。
    *   “隐式广播”是指没有指定目标包名的广播，系统会发送给所有在清单文件中声明了对应 `<intent-filter>` 的应用。
    *   **例外**：一些重要的、不频繁的广播被加入[豁免列表](https://developer.android.com/guide/components/broadcast-exceptions)，如 `ACTION_BOOT_COMPLETED`, `ACTION_LOCALE_CHANGED` 等，这些仍然可以静态注册。
    *   受影响的广播包括：`CONNECTIVITY_ACTION`（网络连接变化）、`ACTION_BATTERY_LOW` 等。对于这些广播，官方推荐使用**动态注册**。

*   **动态注册**：不受此限制影响，在代码中动态注册的接收器仍然可以正常接收这些系统广播。

因此，在开发时，请务必根据 **目标API级别** 和 **广播类型** 来选择合适的注册方式。

### 总结与选择

*   **需要应用未启动时也能接收广播吗？**
    *   **是** -> 检查该广播是否在 Android 8.0+ 的豁免列表中。如果在，使用**静态注册**；如果不在，此路不通，可能需要改用 `JobScheduler` 或 `WorkManager`。
    *   **否** -> 使用**动态注册**。

*   **接收器是否只在某个界面或服务活跃时才需要工作？**
    *   **是** -> 毫无疑问，使用**动态注册**，并在 `onCreate/onStart` 注册，在 `onDestroy/onStop` 解注册。
    *   **否** -> 考虑使用豁免的**静态注册**或其他后台处理机制。

希望这个详细的解释能帮助你彻底理解 BroadcastReceiver 的两种注册方式！